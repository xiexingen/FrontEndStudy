---
title: 虚拟列表
order: 20
nav:
  title: 随笔
  path: /articles
group:
  title: 通用
---

百万数据的展示怎么优化

先看个不经过任何处理的情况下展示

<!-- <code src="./demos/virtual-list/normal.tsx"></code> -->

虚拟列表是啥?

本来需要渲染一百万条数据,但是容器盒子可视范围内只能显示二十条。虚拟列表就是在一百万条数据中,截取可视区域中最多容纳的二十条,即页面中只存在二十个真实的 dom 列表元素。然后监听容器的滚动,实时去更新该二十条数据

# 单项高度固定

一个 ListContainer 盒子,包含一个 ListBox 盒子,在 ListBox 盒子里面渲染每一个列表项。

ListBox 高度 = 每一项的高度 \* 列表项的总条数。使得撑开 ListContainer 盒子,产生滚动条;初始化的时候计算可视区需要显示的条数,以及开始索引,结束索引等。

计算条数时,注意要使用 Math.ceil(),而不是 floor()

监听 ListContainer 盒子的滚动事件,滚动时计算开始索引和结束索引

这就实现了列表的无缝衔接(根据实际情况可以调整下 buffer)

<!-- <code src="./demos/virtual-list/fixed-height-item/index.tsx"></code> -->

# 单项高度不固定

不固定的高度会导致上述的属性无法正常计算:

- 如何获取真实高度
- 相关的属性该如何计算
- 列表渲染的方式有何改变

## 如何获取真实高度

1. 如果能获得列表项高度数组，真实高度问题就很好解决。但在实际渲染之前是很`难拿到每一项的真实高度`的，所以我们采用预估一个高度渲染出真实 DOM，再根据 DOM 的实际情况去设置真实高度

2. 创建一个缓存列表，其中列表项字段为 索引、高度与定位，并`预估列表项高度`用于`初始化缓存列表`。在渲染后根据 DOM 实际情况`更新缓存列表`

## 相关的属性该如何计算

`根据缓存列表重写计算属性、滚动回调函数` ，例如列表总高度的计算可以使用缓存列表最后一项的定位字段的值

## 列表渲染的方式有何改变

- 因为用于渲染页面元素的数据是根据 开始/结束索引 在 数据列表 中筛选出来的，所以只要保证索引的正确计算，那么渲染方式是无需变化的
- 对于开始索引，我们将原先的计算公式改为：在 缓存列表 中搜索第一个底部定位大于 列表垂直偏移量 的项并返回它的索引
- 对于结束索引，它是根据开始索引生成的，无需修改

<!-- <code src="./demos/virtual-list/dynamic-height-item/index.tsx"></code> -->

<!-- <code src="./demos/virtual-list/Container2"></code> -->
